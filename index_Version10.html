<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>YellowSnake – prototype du Sayel Game</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <style>
    :root {
      --bg-gradient: radial-gradient(circle at top, #233c5a 0, #071923 45%, #050b10 100%);
      --panel-bg: rgba(7, 11, 26, 0.96);
      --panel-border: rgba(255, 255, 255, 0.07);
      --text-main: #f9fafb;
      --text-muted: #a9afc6;
      --accent-yellow: #ffd94a;
      --accent-yellow-soft: #ffeeb0;
      --accent-danger: #ff4f6c;
      --accent-success: #7fffb4;
      --accent-blue: #5ecbff;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html,
    body {
      height: 100%;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", sans-serif;
      background: var(--bg-gradient);
      color: var(--text-main);
      display: flex;
      justify-content: center;
      align-items: stretch;
      overflow: hidden;
    }

    .app {
      width: 100%;
      max-width: 960px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    /* Barre du haut */
    .top-bar {
      padding: 10px 14px 8px 14px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      border-radius: 20px 20px 0 0;
      border: 1px solid var(--panel-border);
      border-bottom: none;
      background: rgba(2, 4, 12, 0.9);
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.6);
    }

    .title-wrap {
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
    }

    .title-main {
      font-size: 1.1rem;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: var(--accent-yellow-soft);
      text-shadow:
        0 0 14px rgba(255, 217, 74, 0.8),
        0 0 20px rgba(255, 217, 74, 0.5);
      white-space: nowrap;
    }

    .title-pill {
      font-size: 0.65rem;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: radial-gradient(circle at top left, rgba(255, 255, 255, 0.2), rgba(0, 0, 0, 0.75));
      color: var(--text-muted);
      text-transform: none;
      letter-spacing: 0.02em;
    }

    .subtitle {
      font-size: 0.74rem;
      color: var(--text-muted);
    }

    .subtitle.dev strong {
      color: var(--accent-yellow-soft);
    }

    .hud-right {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .hud-badge {
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.18);
      font-size: 0.7rem;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .hud-label {
      text-transform: uppercase;
      letter-spacing: 0.11em;
      color: var(--text-muted);
      font-size: 0.68rem;
    }

    .hud-value {
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--accent-blue);
    }

    .hud-value.low {
      color: var(--accent-danger);
    }

    .hud-score {
      color: var(--accent-yellow-soft);
    }

    .mode-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent-yellow);
      box-shadow: 0 0 8px rgba(255, 217, 74, 0.9);
    }

    .mode-label {
      font-size: 0.74rem;
    }

    /* Jeu + contrôles */
    .game-and-controls {
      flex: 1;
      display: flex;
      flex-direction: column;
      border-radius: 0 0 20px 20px;
      border: 1px solid var(--panel-border);
      border-top: none;
      background: rgba(7, 11, 26, 0.96);
      box-shadow:
        0 20px 50px rgba(0, 0, 0, 0.9),
        0 0 0 1px rgba(255, 255, 255, 0.02);
    }

    .game-container {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 8px 8px 0 8px;
    }

    /* Canvas responsive */
    .canvas-wrapper {
      position: relative;
      width: 100vw;
      height: 100vw;
      max-width: 700px;
      max-height: min(100vh, 700px);
      margin: 0 auto;
      border-radius: 18px;
      background:
        linear-gradient(135deg, rgba(255, 255, 255, 0.08), rgba(0, 0, 0, 0.85)),
        radial-gradient(circle at 15% 0%, rgba(255, 238, 170, 0.28), transparent 60%),
        radial-gradient(circle at 90% 100%, rgba(142, 255, 211, 0.2), transparent 60%);
      box-shadow:
        0 18px 40px rgba(0, 0, 0, 0.85),
        0 0 0 1px rgba(255, 255, 255, 0.06);
      padding: 10px;
      box-sizing: border-box;
    }

    .canvas-inner {
      position: relative;
      width: 100%;
      height: 100%;
      border-radius: 14px;
      overflow: hidden;
      box-shadow:
        inset 0 0 30px rgba(0, 0, 0, 0.75),
        0 0 0 1px rgba(255, 255, 255, 0.04);
    }

    /* Fond animé + grille */
    .surface-gradient {
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top, #203c46 0, #081c22 55%, #04080c 100%);
      opacity: 0.98;
      z-index: 0;
    }

    .surface-grid {
      position: absolute;
      inset: 0;
      background:
        linear-gradient(to right, rgba(255, 255, 255, 0.04) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(255, 255, 255, 0.04) 1px, transparent 1px);
      background-size: 24px 24px;
      opacity: 0.18;
      mix-blend-mode: soft-light;
      pointer-events: none;
      z-index: 0;
    }

    /* Canvas */
    canvas {
      position: relative;
      display: block;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    /* Overlays */
    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 3;
    }

    .overlay.hidden {
      display: none;
    }

    .overlay-card {
      pointer-events: auto;
      max-width: 360px;
      margin: 12px;
      border-radius: 18px;
      padding: 18px 20px 16px 20px;
      background:
        radial-gradient(circle at top, rgba(255, 247, 199, 0.35), rgba(10, 12, 26, 0.96));
      border: 1px solid rgba(255, 255, 255, 0.18);
      box-shadow:
        0 22px 50px rgba(0, 0, 0, 0.95),
        0 0 0 1px rgba(255, 255, 255, 0.06);
      text-align: center;
      animation: fadeIn 0.25s ease-out;
    }

    .overlay-title {
      font-size: 0.95rem;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: var(--accent-yellow-soft);
      margin-bottom: 6px;
    }

    .overlay-sub {
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-bottom: 10px;
    }

    .overlay-text {
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.82);
      margin-bottom: 12px;
      line-height: 1.4;
    }

    .overlay-keys {
      font-size: 0.74rem;
      color: var(--text-muted);
      margin-bottom: 10px;
    }

    .key-pill {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 18px;
      padding: 3px 7px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.22);
      background: rgba(0, 0, 0, 0.4);
      font-size: 0.72em;
      margin: 0 2px;
    }

    .mode-select {
      display: flex;
      gap: 6px;
      justify-content: center;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }

    .mode-btn {
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(0, 0, 0, 0.5);
      color: var(--text-main);
      padding: 5px 10px;
      font-size: 0.76rem;
      cursor: pointer;
      transition: background 0.12s ease, transform 0.12s ease, box-shadow 0.12s ease;
    }

    .mode-btn.active {
      background: linear-gradient(135deg, #ffe98b, #ffbf1f);
      color: #22130c;
      box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.6), 0 6px 18px rgba(0, 0, 0, 0.8);
    }

    .overlay-btn {
      margin-top: 4px;
      padding: 7px 16px;
      border-radius: 999px;
      border: none;
      outline: none;
      background: linear-gradient(135deg, #ffe98b, #ffbf1f);
      color: #22130c;
      font-size: 0.78rem;
      font-weight: 600;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      cursor: pointer;
      box-shadow:
        0 0 0 1px rgba(255, 255, 255, 0.5),
        0 8px 20px rgba(0, 0, 0, 0.8);
      transition: transform 0.1s ease, box-shadow 0.1s ease, filter 0.1s ease;
    }

    .overlay-btn:hover {
      transform: translateY(-1px);
      filter: brightness(1.05);
      box-shadow:
        0 0 0 1px rgba(255, 255, 255, 0.65),
        0 12px 26px rgba(0, 0, 0, 0.95);
    }

    .overlay-btn:active {
      transform: translateY(1px) scale(0.98);
      box-shadow:
        0 0 0 1px rgba(255, 255, 255, 0.4),
        0 5px 12px rgba(0, 0, 0, 0.9);
    }

    .overlay-msg-defeat {
      color: var(--accent-danger);
      font-weight: 700;
      font-size: 1rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      margin-bottom: 6px;
    }

    .overlay-msg-victory {
      color: var(--accent-success);
      font-weight: 600;
      margin-bottom: 6px;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(6px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Contrôles tactiles */
    .controls-section {
      padding: 4px 10px 10px 10px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }

    .touch-controls {
      flex: 1;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .touch-grid {
      display: grid;
      grid-template-columns: repeat(3, 54px);
      grid-template-rows: repeat(3, 54px);
      gap: 8px;
    }

    .touch-btn {
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.22);
      background: radial-gradient(circle at top, rgba(255, 255, 255, 0.22), rgba(2, 3, 10, 0.98));
      box-shadow:
        0 8px 20px rgba(0, 0, 0, 0.9),
        0 0 0 1px rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-main);
      font-size: 1.1rem;
      cursor: pointer;
      transition: transform 0.1s ease, box-shadow 0.1s ease, background 0.1s ease;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
    }

    .touch-btn.tap-feedback {
      transform: translateY(2px) scale(0.96);
      box-shadow:
        0 4px 10px rgba(0, 0, 0, 0.95),
        0 0 0 1px rgba(255, 255, 255, 0.45);
      background: radial-gradient(circle at top, rgba(255, 255, 255, 0.14), rgba(0, 0, 0, 0.98));
    }

    .touch-btn-empty {
      border: none;
      background: transparent;
      box-shadow: none;
      pointer-events: none;
    }

    .right-controls {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 4px;
    }

    .touch-pause {
      border-radius: 999px;
      padding: 7px 12px;
      font-size: 0.75rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      background: linear-gradient(135deg, rgba(255, 243, 170, 0.25), rgba(255, 223, 135, 0.08));
      border: 1px solid rgba(255, 255, 255, 0.18);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.9);
      cursor: pointer;
      color: var(--text-main);
      min-width: 88px;
    }

    .touch-pause.active {
      background: linear-gradient(135deg, rgba(255, 125, 125, 0.35), rgba(95, 13, 13, 0.95));
      border-color: rgba(255, 163, 163, 0.9);
      color: #ffeaea;
    }

    .hint-text {
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    @media (max-width: 600px) {
      .title-main {
        font-size: 1rem;
      }
      .subtitle {
        display: none;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="top-bar">
      <div class="title-wrap">
        <h1 class="title-main">
          YELLOWSNAKE
          <span class="title-pill">Prototype du Sayel Game</span>
        </h1>
        <p class="subtitle">Bienvenue sur le prototype du Sayel Game !</p>
        <p class="subtitle dev">Développé par <strong>Sayel</strong>.</p>
      </div>
      <div class="hud-right">
        <div class="hud-badge">
          <span class="hud-label">Timer</span>
          <span class="hud-value" id="timer-display">00</span>
        </div>
        <div class="hud-badge">
          <span class="hud-label">Score</span>
          <span class="hud-value hud-score" id="score-display">0</span>
        </div>
        <div class="hud-badge">
          <span class="mode-dot" id="mode-dot"></span>
          <span id="mode-label" class="mode-label">Easy</span>
        </div>
      </div>
    </header>

    <main class="game-and-controls">
      <section class="game-container">
        <div class="canvas-wrapper" id="canvas-wrapper">
          <div class="canvas-inner" id="canvas-inner">
            <div class="surface-gradient"></div>
            <div class="surface-grid"></div>
            <canvas id="game"></canvas>

            <!-- Intro -->
            <div class="overlay" id="overlay-intro">
              <div class="overlay-card">
                <div class="overlay-title">YellowSnake</div>
                <div class="overlay-sub">Bienvenue sur le prototype du Sayel Game !</div>
                <div class="overlay-text">
                  Snake jaune qui grandit en mangeant des œufs.<br />
                  Mort si tu touches un mur, ton corps ou un œuf piégé rouge fissuré.<br />
                  Les murs vibrent légèrement pour un effet vivant.
                </div>
                <div class="mode-select">
                  <button class="mode-btn active" data-mode="easy">Easy</button>
                  <button class="mode-btn" data-mode="challenge">Challenge</button>
                  <button class="mode-btn" data-mode="hardcore">Hardcore</button>
                </div>
                <div class="overlay-keys">
                  Clavier :
                  <span class="key-pill">↑</span>
                  <span class="key-pill">↓</span>
                  <span class="key-pill">←</span>
                  <span class="key-pill">→</span> •
                  <span class="key-pill">Espace</span> = Pause<br />
                  Mobile : swipe ou flèches tactiles.
                </div>
                <button class="overlay-btn" id="btn-start">▶ Jouer</button>
              </div>
            </div>

            <!-- Défaite -->
            <div class="overlay hidden" id="overlay-lose">
              <div class="overlay-card">
                <div class="overlay-msg-defeat">KO ! YellowSnake éliminé</div>
                <div class="overlay-text" id="lose-reason">
                  YellowSnake s’est pris un mur, son corps… ou un œuf piégé.
                </div>
                <div class="overlay-keys">
                  Tap ou <span class="key-pill">Entrée</span> pour rejouer.
                </div>
                <button class="overlay-btn" id="btn-restart-lose">↻ Rejouer</button>
              </div>
            </div>

            <!-- Victoire -->
            <div class="overlay hidden" id="overlay-win">
              <div class="overlay-card">
                <div class="overlay-msg-victory">Challenge réussi !</div>
                <div class="overlay-text">
                  Score final : <strong id="win-score">0</strong><br />
                  YellowSnake a maîtrisé ce niveau.<br />
                  Partage simplement l’URL de cette page.
                </div>
                <div class="overlay-keys">
                  Tap ou <span class="key-pill">Entrée</span> pour rejouer.
                </div>
                <button class="overlay-btn" id="btn-restart-win">↻ Rejouer</button>
              </div>
            </div>
          </div>
        </div>
      </section>

      <!-- Contrôles tactiles -->
      <section class="controls-section">
        <div class="touch-controls" id="touch-controls">
          <div class="touch-grid">
            <div class="touch-btn touch-btn-empty"></div>
            <button class="touch-btn" data-dir="up">▲</button>
            <div class="touch-btn touch-btn-empty"></div>

            <button class="touch-btn" data-dir="left">◀</button>
            <div class="touch-btn touch-btn-empty"></div>
            <button class="touch-btn" data-dir="right">▶</button>

            <div class="touch-btn touch-btn-empty"></div>
            <button class="touch-btn" data-dir="down">▼</button>
            <div class="touch-btn touch-btn-empty"></div>
          </div>
        </div>
        <div class="right-controls">
          <button class="touch-pause" id="btn-touch-pause">Pause</button>
          <p class="hint-text">
            Swipe ou flèches tactiles pour bouger YellowSnake. Timer à 0 = KO instantané.
          </p>
        </div>
      </section>
    </main>
  </div>

  <script>
    // ================== CANVAS & GRID ==================
    const canvas = document.getElementById("game");
    const canvasWrapper = document.getElementById("canvas-wrapper");
    const canvasInner = document.getElementById("canvas-inner");
    const ctx = canvas.getContext("2d");

    let COLS = 20;
    let ROWS = 20;
    let CELL_SIZE = 20;

    function resizeCanvas() {
      const rect = canvasWrapper.getBoundingClientRect();
      const size = Math.min(rect.width, rect.height);

      canvas.width = size;
      canvas.height = size;

      COLS = 20;
      ROWS = 20;
      CELL_SIZE = size / COLS;
    }

    window.addEventListener("resize", () => {
      resizeCanvas();
      render(performance.now());
    });
    resizeCanvas();

    // ================== UI ELEMENTS ==================
    const overlayIntro = document.getElementById("overlay-intro");
    const overlayLose = document.getElementById("overlay-lose");
    const overlayWin = document.getElementById("overlay-win");
    const btnStart = document.getElementById("btn-start");
    const btnRestartLose = document.getElementById("btn-restart-lose");
    const btnRestartWin = document.getElementById("btn-restart-win");
    const modeButtons = document.querySelectorAll(".mode-btn");

    const timerDisplayEl = document.getElementById("timer-display");
    const scoreDisplayEl = document.getElementById("score-display");
    const modeLabelEl = document.getElementById("mode-label");
    const modeDotEl = document.getElementById("mode-dot");
    const loseReasonEl = document.getElementById("lose-reason");
    const winScoreEl = document.getElementById("win-score");
    const winTextEl = document.getElementById("win-text");
    const btnTouchPause = document.getElementById("btn-touch-pause");

    const touchControls = document.getElementById("touch-controls");

    // ================== GAME CONSTANTS ==================
    const GameState = {
      IDLE: "idle",
      RUNNING: "running",
      PAUSED: "paused",
      OVER: "over",
      VICTORY: "victory",
    };

    const SnakeDirection = {
      UP: { x: 0, y: -1 },
      DOWN: { x: 0, y: 1 },
      LEFT: { x: -1, y: 0 },
      RIGHT: { x: 1, y: 0 },
    };

    const EggType = {
      NORMAL: "normal",
      BONUS_TIME: "bonus_time",
      TRAP: "trap",
    };

    const Modes = {
      easy: {
        id: "easy",
        label: "Easy",
        speed: 160,
        timer: 60,
        targetScore: 30,
        trapChance: 0.05,
        bonusChance: 0.05,
        eggLifetime: null,
      },
      challenge: {
        id: "challenge",
        label: "Challenge",
        speed: 110,
        timer: 60,
        targetScore: 60,
        trapChance: 0.10,
        bonusChance: 0.06,
        eggLifetime: null,
      },
      hardcore: {
        id: "hardcore",
        label: "Hardcore",
        speed: 80,
        timer: 45,
        targetScore: 80,
        trapChance: 0.20,
        bonusChance: 0.07,
        eggLifetime: 2500,
      },
    };

    const Game = {
      state: GameState.IDLE,
      mode: Modes.easy,
      snake: [],
      direction: SnakeDirection.RIGHT,
      nextDirection: SnakeDirection.RIGHT,
      food: null,
      foodSpawnTime: 0,
      score: 0,
      speed: Modes.easy.speed,
      lastTick: 0,
      lastFrame: 0,
      timerSeconds: Modes.easy.timer,
      timerIntervalId: null,
      loseReason: "",
      particles: [],
      eatFlashTime: 0,
    };

    // ================== HUD & TIMER ==================
    function updateModeUI() {
      modeLabelEl.textContent = Game.mode.label;
      if (Game.mode.id === "easy") {
        modeDotEl.style.background = "#7fffb4";
      } else if (Game.mode.id === "challenge") {
        modeDotEl.style.background = "#ffe88a";
      } else {
        modeDotEl.style.background = "#ff4f6c";
      }
    }

    function updateScoreUI() {
      scoreDisplayEl.textContent = Game.score;
    }

    function updateTimerDisplay() {
      timerDisplayEl.textContent = String(Game.timerSeconds).padStart(2, "0");
      if (Game.timerSeconds <= 10) {
        timerDisplayEl.classList.add("low");
      } else {
        timerDisplayEl.classList.remove("low");
      }
    }

    function startTimer() {
      Game.timerSeconds = Game.mode.timer;
      updateTimerDisplay();
      if (Game.timerIntervalId) clearInterval(Game.timerIntervalId);
      Game.timerIntervalId = setInterval(() => {
        if (Game.state !== GameState.RUNNING) return;
        Game.timerSeconds -= 1;
        if (Game.timerSeconds <= 0) {
          Game.timerSeconds = 0;
          updateTimerDisplay();
          Game.loseReason = "Timer écoulé.";
          endGame(false);
        } else {
          updateTimerDisplay();
        }
      }, 1000);
    }

    function stopTimer() {
      if (Game.timerIntervalId) {
        clearInterval(Game.timerIntervalId);
        Game.timerIntervalId = null;
      }
    }

    // ================== AUDIO ==================
    let audioCtx = null;
    function ensureAudioContext() {
      if (!audioCtx) {
        try {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch {
          audioCtx = null;
        }
      }
    }

    function playEatSound() {
      ensureAudioContext();
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "sine";
      osc.frequency.setValueAtTime(560, audioCtx.currentTime);
      osc.frequency.linearRampToValueAtTime(820, audioCtx.currentTime + 0.12);
      gain.gain.setValueAtTime(0.07, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.16);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.18);
    }

    function playBonusSound() {
      ensureAudioContext();
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "triangle";
      osc.frequency.setValueAtTime(880, audioCtx.currentTime);
      osc.frequency.linearRampToValueAtTime(660, audioCtx.currentTime + 0.16);
      gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.22);
    }

    function playTrapSound() {
      ensureAudioContext();
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "square";
      osc.frequency.setValueAtTime(240, audioCtx.currentTime);
      osc.frequency.linearRampToValueAtTime(90, audioCtx.currentTime + 0.15);
      gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.25);
    }

    // ================== UTIL ==================
    function randomEmptyCell() {
      while (true) {
        const x = Math.floor(Math.random() * COLS);
        const y = Math.floor(Math.random() * ROWS);
        const collidesSnake = Game.snake.some(s => s.x === x && s.y === y);
        if (!collidesSnake) return { x, y };
      }
    }

    function hideOverlays() {
      overlayIntro.classList.add("hidden");
      overlayLose.classList.add("hidden");
      overlayWin.classList.add("hidden");
    }

    function showOverlay(el) {
      hideOverlays();
      el.classList.remove("hidden");
    }

    // ================== SNAKE & FOOD ==================
    function initSnake() {
      const midX = Math.floor(COLS / 3);
      const midY = Math.floor(ROWS / 2);
      Game.snake = [
        { x: midX - 2, y: midY },
        { x: midX - 1, y: midY },
        { x: midX,     y: midY },
      ];
      Game.direction = SnakeDirection.RIGHT;
      Game.nextDirection = SnakeDirection.RIGHT;
    }

    function spawnFood() {
      const pos = randomEmptyCell();
      let type = EggType.NORMAL;
      const r = Math.random();
      if (r < Game.mode.bonusChance) {
        type = EggType.BONUS_TIME;
      } else if (r < Game.mode.bonusChance + Game.mode.trapChance) {
        type = EggType.TRAP;
      } else {
        type = EggType.NORMAL;
      }
      Game.food = { x: pos.x, y: pos.y, type };
      Game.foodSpawnTime = performance.now();
    }

    // ================== PARTICULES ==================
    function spawnParticles(gridX, gridY, color) {
      const cx = gridX * CELL_SIZE + CELL_SIZE / 2;
      const cy = gridY * CELL_SIZE + CELL_SIZE / 2;
      const count = 8;
      for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 * i) / count;
        const speed = 1 + Math.random() * 1.2;
        Game.particles.push({
          x: cx,
          y: cy,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 220,
          size: 2 + Math.random() * 2,
          color,
        });
      }
    }

    function updateParticles(delta) {
      Game.particles = Game.particles.filter(p => {
        p.life -= delta;
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.004 * (delta / 16);
        return p.life > 0;
      });
    }

    function drawParticles() {
      Game.particles.forEach(p => {
        const t = Math.max(0, p.life / 220);
        const alpha = t;
        const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 2);
        grad.addColorStop(0, `rgba(255,255,255,${alpha})`);
        grad.addColorStop(1, p.color.replace("ALPHA", 0));
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * 2, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    // ================== RENDER ==================
    function drawBackgroundLayer() {
      const grad = ctx.createRadialGradient(
        canvas.width / 2,
        canvas.height / 2,
        canvas.width / 5,
        canvas.width / 2,
        canvas.height / 2,
        canvas.width / 1.2
      );
      grad.addColorStop(0, "rgba(0,0,0,0)");
      grad.addColorStop(1, "rgba(0,0,0,0.4)");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const t = performance.now() / 800;
      const pulse = (Math.sin(t * 2) + 1) / 2;
      const wallWidth = 3 + pulse * 2;

      const wallOpacityBase =
        Game.mode.id === "easy" ? 0.18 :
        Game.mode.id === "challenge" ? 0.28 : 0.4;

      const wallGrad = ctx.createLinearGradient(0, 0, canvas.width, 0);
      wallGrad.addColorStop(0, `rgba(255,255,255,${wallOpacityBase})`);
      wallGrad.addColorStop(0.5, `rgba(255,255,255,${wallOpacityBase + pulse * 0.15})`);
      wallGrad.addColorStop(1, `rgba(255,255,255,${wallOpacityBase})`);

      ctx.strokeStyle = wallGrad;
      ctx.lineWidth = wallWidth;
      ctx.strokeRect(
        wallWidth,
        wallWidth,
        canvas.width - wallWidth * 2,
        canvas.height - wallWidth * 2
      );
    }

    function drawSnake() {
      const segments = Game.snake;
      for (let i = 0; i < segments.length; i++) {
        const seg = segments[i];
        const x = seg.x * CELL_SIZE;
        const y = seg.y * CELL_SIZE;
        const isHead = i === segments.length - 1;

        const radius = CELL_SIZE / 2 - (isHead ? 1 : 3);
        const cx = x + CELL_SIZE / 2;
        const cy = y + CELL_SIZE / 2;

        const grad = ctx.createRadialGradient(
          cx - 3, cy - 3, 2,
          cx, cy, radius + 2
        );
        const baseColor = isHead ? "#ffeaa0" : "#ffd94a";
        grad.addColorStop(0, "#fffdf0");
        grad.addColorStop(0.5, baseColor);
        grad.addColorStop(1, "#f2b91a");

        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.roundRect(
          x + 3,
          y + 3,
          CELL_SIZE - 6,
          CELL_SIZE - 6,
          CELL_SIZE / 2.3
        );
        ctx.fill();

        ctx.strokeStyle = "rgba(0,0,0,0.35)";
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(x + 5, y + 5);
        ctx.quadraticCurveTo(x + CELL_SIZE / 2, y + 2, x + CELL_SIZE - 6, y + 5);
        ctx.strokeStyle = "rgba(255,255,255,0.3)";
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      const head = segments[segments.length - 1];
      const hx = head.x * CELL_SIZE;
      const hy = head.y * CELL_SIZE;
      ctx.fillStyle = "#24242e";
      const eyeSize = Math.max(2.5, CELL_SIZE * 0.16);
      let lx, ly, rx, ry;

      if (Game.direction === SnakeDirection.RIGHT) {
        lx = hx + CELL_SIZE - eyeSize * 2.2;
        rx = hx + CELL_SIZE - eyeSize * 2.2;
        ly = hy + eyeSize * 1.5;
        ry = hy + CELL_SIZE - eyeSize * 2.1;
      } else if (Game.direction === SnakeDirection.LEFT) {
        lx = hx + eyeSize * 1.6;
        rx = hx + eyeSize * 1.6;
        ly = hy + eyeSize * 1.5;
        ry = hy + CELL_SIZE - eyeSize * 2.1;
      } else if (Game.direction === SnakeDirection.DOWN) {
        lx = hx + eyeSize * 1.7;
        rx = hx + CELL_SIZE - eyeSize * 2.1;
        ly = hy + CELL_SIZE - eyeSize * 2.1;
        ry = hy + CELL_SIZE - eyeSize * 2.1;
      } else {
        lx = hx + eyeSize * 1.7;
        rx = hx + CELL_SIZE - eyeSize * 2.1;
        ly = hy + eyeSize * 1.6;
        ry = hy + eyeSize * 1.6;
      }
      ctx.beginPath();
      ctx.arc(lx, ly, eyeSize / 2, 0, Math.PI * 2);
      ctx.arc(rx, ry, eyeSize / 2, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawEgg() {
      if (!Game.food) return;
      const { x, y, type } = Game.food;
      const px = x * CELL_SIZE;
      const py = y * CELL_SIZE;
      const now = performance.now();

      let flicker = 1;
      if (type === EggType.TRAP) {
        const t = (now / 200) % 2;
        flicker = t < 1 ? 1 : 0.4;
      }

      let inset = 3;
      let c1 = "#ffffff", c2 = "#f2f2f2", c3 = "#dcdcdc";

      if (type === EggType.BONUS_TIME) {
        c1 = "#e6fbff";
        c2 = "#bbf1ff";
        c3 = "#68d9ff";
      } else if (type === EggType.TRAP) {
        c1 = `rgba(255,230,230,${flicker})`;
        c2 = `rgba(255,150,150,${flicker})`;
        c3 = `rgba(255,80,80,${flicker})`;
      }

      if (Game.mode.eggLifetime && type === EggType.NORMAL) {
        const elapsed = now - Game.foodSpawnTime;
        const t = Math.min(1, elapsed / Game.mode.eggLifetime);
        inset = 3 + t * 4;
        if (elapsed > Game.mode.eggLifetime) {
          spawnFood();
          return;
        }
      }

      const width = CELL_SIZE - inset * 2;
      const height = CELL_SIZE - inset * 2;
      const cx = px + CELL_SIZE / 2;
      const cy = py + CELL_SIZE / 2;

      ctx.save();
      ctx.translate(cx, cy - 1);

      const rx = width / 2;
      const ry = height / 2;

      const grad = ctx.createRadialGradient(0, -ry / 2, 2, 0, 0, ry + 4);
      grad.addColorStop(0, c1);
      grad.addColorStop(0.5, c2);
      grad.addColorStop(1, c3);
      ctx.fillStyle = grad;

      ctx.beginPath();
      ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2);
      ctx.fill();

      if (type === EggType.TRAP) {
        ctx.strokeStyle = "#5b1010";
        ctx.lineWidth = 1.6;
        ctx.beginPath();
        ctx.moveTo(0, -ry + 4);
        ctx.lineTo(3, -2);
        ctx.lineTo(-2, 4);
        ctx.lineTo(2, ry - 4);
        ctx.stroke();
      }

      if (type === EggType.BONUS_TIME) {
        ctx.strokeStyle = "#174f7a";
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(-3, 0);
        ctx.lineTo(3, 0);
        ctx.moveTo(0, -3);
        ctx.lineTo(0, 3);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawEatFlash() {
      if (!Game.eatFlashTime) return;
      const now = performance.now();
      const elapsed = now - Game.eatFlashTime;
      const duration = 140;
      if (elapsed > duration) {
        Game.eatFlashTime = 0;
        return;
      }
      const alpha = 1 - elapsed / duration;
      const grad = ctx.createRadialGradient(
        canvas.width / 2,
        canvas.height / 2,
        0,
        canvas.width / 2,
        canvas.height / 2,
        canvas.width / 2
      );
      grad.addColorStop(0, `rgba(255,247,210,${0.18 * alpha})`);
      grad.addColorStop(1, "rgba(255,247,210,0)");
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function render(timestamp) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBackgroundLayer();
      drawEgg();
      drawSnake();
      drawParticles();
      drawEatFlash();
    }

    // ================== GAME LOOP ==================
    function updateGame(timestamp) {
      if (Game.state !== GameState.RUNNING) return;

      const delta = timestamp - Game.lastTick;
      const deltaFrame = timestamp - Game.lastFrame;
      Game.lastFrame = timestamp;

      if (delta < Game.speed) {
        render(timestamp);
        requestAnimationFrame(updateGame);
        return;
      }
      Game.lastTick = timestamp;

      const head = Game.snake[Game.snake.length - 1];
      Game.direction = Game.nextDirection;
      const newHead = {
        x: head.x + Game.direction.x,
        y: head.y + Game.direction.y,
      };

      if (newHead.x < 0 || newHead.x >= COLS || newHead.y < 0 || newHead.y >= ROWS) {
        Game.loseReason = "YellowSnake a heurté un mur.";
        return endGame(false);
      }

      if (Game.snake.some(seg => seg.x === newHead.x && seg.y === newHead.y)) {
        Game.loseReason = "YellowSnake s’est mordu lui-même.";
        return endGame(false);
      }

      Game.snake.push(newHead);

      let ateFood = false;
      if (Game.food && newHead.x === Game.food.x && newHead.y === Game.food.y) {
        ateFood = true;
        if (Game.food.type === EggType.TRAP) {
          Game.loseReason = "Œuf piégé mangé.";
          spawnParticles(newHead.x, newHead.y, "rgba(255,110,110,ALPHA)");
          playTrapSound();
          return endGame(false);
        } else if (Game.food.type === EggType.BONUS_TIME) {
          Game.score++;
          Game.timerSeconds = Math.min(Game.timerSeconds + 5, Game.mode.timer + 20);
          updateTimerDisplay();
          updateScoreUI();
          Game.eatFlashTime = performance.now();
          spawnParticles(newHead.x, newHead.y, "rgba(120,220,255,ALPHA)");
          playBonusSound();
        } else {
          Game.score++;
          updateScoreUI();
          Game.eatFlashTime = performance.now();
          spawnParticles(newHead.x, newHead.y, "rgba(255,220,140,ALPHA)");
          playEatSound();
        }

        if (Game.score >= Game.mode.targetScore) {
          return endGame(true);
        }

        spawnFood();
      }

      if (!ateFood) {
        Game.snake.shift();
      }

      updateParticles(deltaFrame);
      render(timestamp);
      requestAnimationFrame(updateGame);
    }

    // ================== START / END / PAUSE ==================
    function startGame(withIntroAnimation = true) {
      Game.state = GameState.RUNNING;
      Game.score = 0;
      Game.speed = Game.mode.speed;
      Game.particles = [];
      Game.eatFlashTime = 0;
      Game.loseReason = "";

      initSnake();
      spawnFood();
      updateScoreUI();
      hideOverlays();
      startTimer();

      const startLoop = () => {
        Game.lastTick = performance.now();
        Game.lastFrame = Game.lastTick;
        render(Game.lastTick);
        requestAnimationFrame(updateGame);
      };

      if (withIntroAnimation) {
        animateIntro(startLoop);
      } else {
        startLoop();
      }
      updatePauseButton();
    }

    function endGame(victory) {
      Game.state = victory ? GameState.VICTORY : GameState.OVER;
      stopTimer();
      if (victory) {
        winScoreEl.textContent = Game.score;
        winTextEl.innerHTML =
          `Score final : <strong>${Game.score}</strong> en mode <strong>${Game.mode.label}</strong>.<br/>YellowSnake a survécu au timer et aux œufs piégés.`;
        showOverlay(overlayWin);
      } else {
        loseReasonEl.textContent = Game.loseReason || "Défaite.";
        showOverlay(overlayLose);
      }
      updatePauseButton();
    }

    function togglePause(fromTouch = false) {
      if (Game.state === GameState.OVER || Game.state === GameState.VICTORY || Game.state === GameState.IDLE) return;
      if (Game.state === GameState.RUNNING) {
        Game.state = GameState.PAUSED;
        stopTimer();
      } else if (Game.state === GameState.PAUSED) {
        Game.state = GameState.RUNNING;
        startTimer();
        Game.lastTick = performance.now();
        Game.lastFrame = Game.lastTick;
        requestAnimationFrame(updateGame);
      }
      if (fromTouch) ensureAudioContext();
      updatePauseButton();
    }

    function updatePauseButton() {
      if (!btnTouchPause) return;
      if (Game.state === GameState.RUNNING) {
        btnTouchPause.textContent = "Pause";
        btnTouchPause.classList.remove("active");
      } else if (Game.state === GameState.PAUSED) {
        btnTouchPause.textContent = "Reprendre";
        btnTouchPause.classList.add("active");
      } else {
        btnTouchPause.textContent = "Pause";
        btnTouchPause.classList.remove("active");
      }
    }

    // ================== INTRO ANIM ==================
    function animateIntro(onDone) {
      const steps = 24;
      let current = 0;
      const origSnake = Game.snake.map(s => ({ ...s }));
      const amplitude = 0.5;

      function frame() {
        current++;
        const factor = current / steps;

        const t = performance.now();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackgroundLayer();
        drawEgg();

        const tempSnake = origSnake.map((seg, idx) => {
          const offset = Math.sin(factor * Math.PI * 1.4 + idx * 0.6) * amplitude;
          return { x: seg.x + offset, y: seg.y };
        });

        tempSnake.forEach((segment, i) => {
          const isHead = i === tempSnake.length - 1;
          const x = segment.x * CELL_SIZE;
          const y = segment.y * CELL_SIZE;

          const radius = CELL_SIZE / 2 - (isHead ? 1 : 3);
          const cx = x + CELL_SIZE / 2;
          const cy = y + CELL_SIZE / 2;
          const grad = ctx.createRadialGradient(
            cx - 3, cy - 3, 2,
            cx, cy, radius + 2
          );
          const baseColor = isHead ? "#ffeaa0" : "#ffd94a";
          grad.addColorStop(0, "#fffdf0");
          grad.addColorStop(0.5, baseColor);
          grad.addColorStop(1, "#f2b91a");

          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.roundRect(
            x + 3,
            y + 3,
            CELL_SIZE - 6,
            CELL_SIZE - 6,
            CELL_SIZE / 2.3
          );
          ctx.fill();
          ctx.strokeStyle = "rgba(0,0,0,0.35)";
          ctx.lineWidth = 1;
          ctx.stroke();
        });

        if (current < steps) {
          requestAnimationFrame(frame);
        } else {
          render(t);
          if (typeof onDone === "function") onDone();
        }
      }

      frame();
    }

    // ================== INPUT CLAVIER ==================
    document.addEventListener("keydown", (e) => {
      const key = e.key;

      if (Game.state === GameState.IDLE && key === "Enter") {
        e.preventDefault();
        startGame(true);
        return;
      }

      if (Game.state === GameState.OVER || Game.state === GameState.VICTORY) {
        if (key === "Enter") {
          e.preventDefault();
          startGame(true);
        }
        return;
      }

      switch (key) {
        case "ArrowUp":
          e.preventDefault();
          if (Game.direction !== SnakeDirection.DOWN) Game.nextDirection = SnakeDirection.UP;
          break;
        case "ArrowDown":
          e.preventDefault();
          if (Game.direction !== SnakeDirection.UP) Game.nextDirection = SnakeDirection.DOWN;
          break;
        case "ArrowLeft":
          e.preventDefault();
          if (Game.direction !== SnakeDirection.RIGHT) Game.nextDirection = SnakeDirection.LEFT;
          break;
        case "ArrowRight":
          e.preventDefault();
          if (Game.direction !== SnakeDirection.LEFT) Game.nextDirection = SnakeDirection.RIGHT;
          break;
        case " ":
          e.preventDefault();
          togglePause(false);
          break;
      }
    });

    // ================== TOUCH BUTTONS ==================
    function addTapFeedback(el) {
      el.classList.add("tap-feedback");
      setTimeout(() => el.classList.remove("tap-feedback"), 120);
    }

    function setupTouchButtons() {
      const buttons = document.querySelectorAll(".touch-btn[data-dir]");
      buttons.forEach(btn => {
        const dir = btn.getAttribute("data-dir");
        const handler = (evt) => {
          evt.preventDefault();
          addTapFeedback(btn);
          if (Game.state === GameState.OVER || Game.state === GameState.VICTORY) return;
          switch (dir) {
            case "up":
              if (Game.direction !== SnakeDirection.DOWN) Game.nextDirection = SnakeDirection.UP;
              break;
            case "down":
              if (Game.direction !== SnakeDirection.UP) Game.nextDirection = SnakeDirection.DOWN;
              break;
            case "left":
              if (Game.direction !== SnakeDirection.RIGHT) Game.nextDirection = SnakeDirection.LEFT;
              break;
            case "right":
              if (Game.direction !== SnakeDirection.LEFT) Game.nextDirection = SnakeDirection.RIGHT;
              break;
          }
        };
        btn.addEventListener("click", handler);
        btn.addEventListener("touchstart", handler, { passive: false });
      });

      const pauseHandler = (evt) => {
        evt.preventDefault();
        addTapFeedback(btnTouchPause);
        togglePause(true);
      };
      btnTouchPause.addEventListener("click", pauseHandler);
      btnTouchPause.addEventListener("touchstart", pauseHandler, { passive: false });
    }

    // ================== SWIPE ==================
    let touchStartX = null;
    let touchStartY = null;
    let touchStartTime = null;

    function setupSwipe() {
      const area = canvasInner;

      area.addEventListener("touchstart", (e) => {
        if (!e.touches || e.touches.length !== 1) return;
        const t = e.touches[0];
        touchStartX = t.clientX;
        touchStartY = t.clientY;
        touchStartTime = performance.now();
      }, { passive: true });

      area.addEventListener("touchend", (e) => {
        if (touchStartX === null || touchStartY === null) return;
        const dx = (e.changedTouches[0].clientX - touchStartX);
        const dy = (e.changedTouches[0].clientY - touchStartY);
        const dt = performance.now() - touchStartTime;

        const dist = Math.hypot(dx, dy);
        const minDist = 20;
        const maxTime = 400;

        if (dist > minDist && dt < maxTime) {
          const absDx = Math.abs(dx);
          const absDy = Math.abs(dy);
          Game.eatFlashTime = performance.now(); // léger feedback

          if (absDx > absDy) {
            if (dx > 0 && Game.direction !== SnakeDirection.LEFT) {
              Game.nextDirection = SnakeDirection.RIGHT;
            } else if (dx < 0 && Game.direction !== SnakeDirection.RIGHT) {
              Game.nextDirection = SnakeDirection.LEFT;
            }
          } else {
            if (dy > 0 && Game.direction !== SnakeDirection.UP) {
              Game.nextDirection = SnakeDirection.DOWN;
            } else if (dy < 0 && Game.direction !== SnakeDirection.DOWN) {
              Game.nextDirection = SnakeDirection.UP;
            }
          }
        }

        touchStartX = null;
        touchStartY = null;
        touchStartTime = null;
      }, { passive: true });
    }

    // ================== MODES & BOUTONS OVERLAY ==================
    modeButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        modeButtons.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        const id = btn.getAttribute("data-mode");
        Game.mode = Modes[id];
        Game.speed = Game.mode.speed;
        updateModeUI();
        Game.timerSeconds = Game.mode.timer;
        updateTimerDisplay();
      });
    });

    btnStart.addEventListener("click", () => startGame(true));
    btnRestartLose.addEventListener("click", () => startGame(true));
    btnRestartWin.addEventListener("click", () => startGame(true));

    overlayLose.addEventListener("click", () => {
      if (Game.state === GameState.OVER) startGame(true);
    });
    overlayWin.addEventListener("click", () => {
      if (Game.state === GameState.VICTORY) startGame(true);
    });

    // ================== INIT ==================
    function init() {
      Game.state = GameState.IDLE;
      Game.mode = Modes.easy;
      Game.speed = Game.mode.speed;
      Game.timerSeconds = Game.mode.timer;
      initSnake();
      spawnFood();
      updateModeUI();
      updateTimerDisplay();
      updateScoreUI();
      setupTouchButtons();
      setupSwipe();
      render(performance.now());
      showOverlay(overlayIntro);
    }

    init();
  </script>
</body>
</html>